from typing import Tuple

from math import sqrt

import torch
from torch import Tensor

from geometry import vector


def _non_zero_vector(x: Tensor, eps: float = 1e-6) -> Tensor:
    """
    Add noise to vector in order to ensure that it's not the null vector.

    :param x: Vector of shape [*, N, 1].
    :param eps: Threshold of the vector's norm.
    :return: Non-zero vector of shape [*, N, 1].
    """
    assert x.shape[-1] == 1
    assert eps > 0

    m = vector.norm(x) < eps

    while m.any():
        x = x + m * eps * torch.randn_like(x)
        m = vector.norm(x) < eps

    return x


def _non_colinear_vectors(
    x: Tensor,
    y: Tensor,
    eps: float = 1e-6,
) -> Tuple[Tensor, Tensor]:
    """
    Iteratively add noise to the vector with the smallest norm in order to ensure their non-colinearity.

    :param x: Vector of shape [*, N, 1].
    :param y: Vector of shape [*, N, 1].
    :param eps: Threshold of the cosine similarity product.
    :return: Vectors of shape [*, N, 1] and [*, N, 1] respectively.
    """
    assert x.shape[-2] == y.shape[-2]
    assert x.shape[-1] == y.shape[-1] == 1
    assert 0 < eps < 1

    m = (1.0 - vector.cosine_similarity(x, y).abs()) < eps
    n = vector.norm(x) < vector.norm(y)

    while m.any():
        x = x + sqrt(eps) * m * n * torch.randn_like(x)
        y = y + sqrt(eps) * m * ~n * torch.randn_like(y)

        m = (1.0 - vector.cosine_similarity(x, y).abs()) < eps
        n = vector.norm(x) < vector.norm(y)

    return x, y


def cross_rotation(x: Tensor, y: Tensor) -> Tensor:
    """
    Compute a rotation matrix (in SO(3)) between two non-colinear vectors.
    R is defined such that x = R @ e_1.
    If you don't ensure the non-colinearity of the vectors, the rotation might be very wrong!

    :param x: Vector of shape [*, 3, 1].
    :param y: Vector of shape [*, 3, 1].
    :return: Rotation matrix of shape [*, 3, 3].
    """
    assert x.shape == y.shape
    assert x.shape[-2] == y.shape[-2] == 3
    assert x.shape[-1] == y.shape[-1] == 1

    x = _non_zero_vector(x)
    y = _non_zero_vector(y)

    x = vector.normalize(x)
    y = vector.normalize(y)

    x, y = _non_colinear_vectors(x, y)

    u = vector.normalize(x)
    w = u.cross(y, dim=-2)
    w = vector.normalize(w)
    v = w.cross(u, dim=-2)
    R = torch.cat([u, v, w], dim=-1)

    return R


def vector_rotation(x: Tensor, y: Tensor) -> Tensor:
    """
    Compute the rotation matrix between two non-zero vectors, such that Rx = y.
    If you don't ensure non-nullity of the vectors, the rotation might be very wrong!

    :param x: Vector of shape [*, N, 1].
    :param y: Vector of shape [*, N, 1].
    :param eps: Numerical stability term.
    :return: Rotation matrix of shape [*, N, N].
    """
    assert x.shape == y.shape
    assert x.shape[-1] == y.shape[-1] == 1

    n = x.shape[-2]

    x = _non_zero_vector(x)
    y = _non_zero_vector(y)

    x = vector.normalize(x)
    y = vector.normalize(y)

    # Ensure x and y are not colinear.
    x, y = _non_colinear_vectors(x, y)

    # Compute normalized orthogonal vectors.
    u = vector.normalize(x)
    v = y - (u.transpose(-1, -2) @ y) * u
    v = vector.normalize(v)

    # Compute the cos and sin of the rotation matrix.
    cos = vector.cosine_similarity(x, y)
    sin = (1.0 - cos ** 2).sqrt()

    # Rotation matrix on the plane generated by x and y.
    a = torch.cat([u, v], dim=-1)
    b = torch.cat(
        [
            torch.cat([cos, -sin], dim=-1),
            torch.cat([sin, cos], dim=-1),
        ],
        dim=-2,
    )

    # Projection onto the space generated by x and y.
    P = vector.outer(u, u) + vector.outer(v, v)
    # Projection onto the complemented space generated by x and y.
    Q = torch.eye(n, dtype=P.dtype, device=P.device) - P
    # Compute the rotation.
    R = Q + a @ b @ a.transpose(-1, -2)

    return R


def _r_x(pitch: Tensor) -> Tensor:
    c, s = pitch.cos(), pitch.sin()
    z, o = torch.zeros_like(c), torch.ones_like(c)
    R = torch.stack(
        [
            torch.stack([o, z, z], dim=-1),
            torch.stack([z, c, -s], dim=-1),
            torch.stack([z, s, c], dim=-1),
        ],
        dim=-2,
    )
    return R


def _r_y(yaw: Tensor) -> Tensor:
    c, s = yaw.cos(), yaw.sin()
    z, o = torch.zeros_like(c), torch.ones_like(c)
    R = torch.stack(
        [
            torch.stack([c, z, s], dim=-1),
            torch.stack([z, o, z], dim=-1),
            torch.stack([-s, z, c], dim=-1),
        ],
        dim=-2,
    )
    return R


def _r_z(roll: Tensor) -> Tensor:
    c, s = roll.cos(), roll.sin()
    z, o = torch.zeros_like(c), torch.ones_like(c)
    R = torch.stack(
        [
            torch.stack([c, -s, z], dim=-1),
            torch.stack([s, c, z], dim=-1),
            torch.stack([z, z, o], dim=-1),
        ],
        dim=-2,
    )
    return R


def euler_rotation(yaw: Tensor, pitch: Tensor, roll: Tensor) -> Tensor:
    return _r_y(yaw) @ _r_x(pitch) @ _r_z(roll)
